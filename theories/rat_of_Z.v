From mathcomp Require all_algebra. (* Remove this line when requiring Rocq > 9.1 *)
From HB Require Import structures.
Require Import ZArith.
From mathcomp Require Import all_ssreflect ssralg ssrnum ssrint rat.
From mathcomp.zify Require Export ssrZ.
Require Import tactics.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Import Order.Theory GRing.Theory Num.Theory.

Local Open Scope ring_scope.

(*  We define an *opaque* cast:                                                *)
(*     rat_of_Z : Z -> rat                                                     *)
(* which converts integers in the type Z of integers in binary representation, *)
(* into the type rat of rational numbers from the MathComp lib, which is       *)
(* equipped with all the (appropriate) structures of ssralg but not relevant   *)
(* for inner computations. *)
(* This cast is useful to control computation when doing proofs on expressions *)
(* that feature "large" numeral constants. Also this is a mandatory ingredient *)
(* in the custom ring/field tactics we use. *)

(* Definition of the cast. In our case, it is crucial that this cast is *)
(* opaque, otherwise we cannot control when binary integers are converted *)
(* to (unary) rationals.*)

(* Opacification of rat_of_Z. A mere 'locked' would not word for it is not *)
(* fully opaque and would be actually harmeful in the hard-wired post *)
(* treatement of the postconditions generated by the (coq, primitive) field *)
(* tactic. *)

Module Type RatOfZSig.
Parameter rat_of_Z : Z -> rat.
Axiom rat_of_ZEdef : rat_of_Z = (fun x : Z => (int_of_Z x)%:Q).
End RatOfZSig.

Module rat_of_ZDef : RatOfZSig.
Definition rat_of_Z (x : Z) := (int_of_Z x)%:Q.
Definition rat_of_ZEdef := erefl rat_of_Z.
End rat_of_ZDef.

Export rat_of_ZDef.

Fact rat_of_Z_is_additive : additive rat_of_Z.
Proof. by move=> m n; rewrite rat_of_ZEdef !raddfB. Qed.

HB.instance Definition _ :=
  GRing.isAdditive.Build Z rat rat_of_Z rat_of_Z_is_additive.

Fact rat_of_Z_is_multiplicative : multiplicative rat_of_Z.
Proof. by rewrite rat_of_ZEdef; exact: rmorphismMP (_ \o _). Qed.

HB.instance Definition _ :=
  GRing.isMultiplicative.Build Z rat rat_of_Z rat_of_Z_is_multiplicative.

Lemma zify_rat_of_Z_subproof n : rat_of_Z n = (int_of_Z n)%:~R.
Proof. by rewrite rat_of_ZEdef. Qed.

Canonical zify_rat_of_Z n :=
  ZifyRing (rat_of_Z n) (int_of_Z n) (zify_rat_of_Z_subproof n).

(* Compatibility with order. This is a stub. *)

Lemma rat_of_Z_Zpos (z : positive) : 0 < rat_of_Z (Zpos z).
Proof. by ring_lia. Qed.
#[export] Hint Resolve rat_of_Z_Zpos : core.

Fact lt_rat_of_Z (n m : Z) : (n < m)%Z -> rat_of_Z n < rat_of_Z m.
Proof. by ring_lia. Qed.

Fact le_rat_of_Z (n m : Z) : (n <= m)%Z -> rat_of_Z n <= rat_of_Z m.
Proof. by ring_lia. Qed.

Lemma rat_of_Z_ZposW z : 0 <= rat_of_Z (Zpos z).
Proof. exact: ltW. Qed.

Lemma rat_of_Z_of_nat n : rat_of_Z (Z.of_nat n) = n%:Q.
Proof. by apply/eqP; ring_lia. Qed.

Lemma rat_of_Z_pow z n : rat_of_Z (z ^ Z.of_nat n) = rat_of_Z z ^ n.
Proof.
rewrite /exprz -rmorphXn -Zpower_nat_Z; congr rat_of_Z.
by elim: n => //= n ->; rewrite exprS.
Qed.
#[export] Hint Resolve rat_of_Z_ZposW : core.
